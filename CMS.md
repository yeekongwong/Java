# CMS

---

### 1.前言
> 在G1之前，大家都知道有三种垃圾收集器，分别是串行收集器，并行收集器以及并发标记清除收集器

### 2.CMS(Concurrent Mark Sweep)
>  CMS是一款以获取最小停顿时间为目的，主要针对老年代进行回收，并发且使用标记清除算法的垃圾回收器。主要的应用场景：在一些对响应时间有很高要求的应用或网站中，用户程序不能有长时间的停顿。总的来说可以分为六个阶段，分别为：
1.初始标记(STW)
暂停用户线程进行可达性分析，标记GC ROOT可以直接关联到的对象
2.并发标记
从第一阶段标记过的对象触发，所有可到达的对象都在本阶段中标记
3.并发预清理
由于CMS主要以获取最短停顿时间为目的的GC,而重标记需要STW,所以重标记的工作尽可能在并发阶段完成来减少SWT的时间；**主要标记从新生代晋升的对象，新分配到老年代的对象以及在并发标记阶段被修改了的对象**
问题：如何确保老年代中的对象是活着？
1）直接通过GC ROOT可到达的对象
2）通过扫描新生代来确保（因为有些老年代对象是被新生代的对象引用着）
为了确保老年代的对象是活着，故需要全量的扫描新生代和老年代，但全量扫描肯定会需要很大的停顿时间，那CMS如何保证扫描时快呢？那就得有一个快速识别新生代和老年代活着对象机制
1）新生代：通过Minor GC 因为新生代回收完剩下的对象全是活着，且活着对象很少
2）老年代：通过一个叫CARDTABLE来快速识别存活对象；在老年代中，CMS会把老年代划分为512bytes的块，card table中的每个元素对应这一个块。即在并发标记之后，某个对象的引用发生变化了，则标记为该对象所在的块为dirty card。在此阶段会重新扫描这块，并将标志为可达。
另外，也可以通过card table来标志老年代是否引用了新生代，所以Minor GC通过扫描card table可以很快识别老年代引用新生代。
引申：
1）Minor GC 会清理年轻代的内存
4.重标记(STW)
暂停所有用户线程，重新扫描对堆中对象进行可达性分析，标记存活对象(多线程)
5.并发清理
用户线程重新启动，同时清理无效对象
6.重置
CMS清除内部状态，准备下一次回收

### 3.CMS存在问题
1.并发意味着多线程抢占CPU资源，即GC线程与用户线程抢占CPU,会造成用户线程效率下降；
2.并发过程中用户线程还在运行，可能会产生新垃圾，但在此次GC无法清除，只能等下次；
3.由于使用了标记清除算法，会导致大量空间碎片，导致容易触发Full GC。

### 4.总结
1.采用了多种方式降低GC暂停时间，减少用户程序停顿
2.降低用户程序停顿时间却牺牲了CPU吞吐量





