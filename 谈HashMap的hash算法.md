# 谈HashMap的hash算法

标签（空格分隔）： Java

---
> 本文此次主要围绕hashmap的hash算法也展开讨论。
## 1.2次幂
> + 可以直接用&运算而避免用%取模，提高性能效率
+ 空间浪费问题；假设不是2次幂，那么二进制一定有一位为0的，那么再&运算时会造成这一位的永远为0 ，也加大了碰撞
## 2.扰动函数
```
#Java 8中的散列值优化函数
 static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```
>首先搬出来的是hashmap中的hash的源代码，对于这段代码，主要的一个重点有两个：
+ **^ 异或的运算**
+ **h >>> 16** 
> 在上述中会对key调用hashcode的函数，返回的是一个int类型的散列值。如果直接拿散列值作为下标访问HashMap主数组的话，考虑到2进制32位带符号的int表值范围从-2147483648到2147483648。前后加起来大概40亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。
    但问题是一个40亿长度的数组，内存是放不下的。你想，HashMap扩容之前的数组初始大小才16。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。
> 然后来看看在get或put的过程中，会做了一个取模的操作，**(p = tab[i = (n - 1) & hash])** 如果没有事先对hashcode提前hash的操作，会有什么样的问题呢？假设这里的n=16，则进行的是15&hash运算。假设有一种情况，如下所述，很明显这种散列不好。
    对象 A 的 hashCode 为 10000100011100010000011110000000&1111 = 0
    对象 B 的 hashCode 为 01110111001110001010000101000000&1111 = 0
结论表明，尽管散列值再怎么散列，若只是取后几位还是会发生碰撞的。所以，有了扰动函数的出现。
>扰动函数里面，主要将高16位和低16位进行了一个异或运算，为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。




