# 逃逸分析
> Java开发码农都知道，Java创建的对象都是分配到堆内存里面的；但是，这个不是绝对的。在Java对象分配过程中分析，会有两个地方会导致Java中创建出来的对象并一定分别在认为的堆上，这两个点分别是逃逸分析和TLAB线程私有的缓冲区。

---
## 1.概念
> 当变量或者对象在方法中分配后，其指针有可能被返回或者被全局引用，这样会造成被其他过程或者线程所引用，这种就叫做指针（引用）的逃逸。

---
## 2.逃逸前后区别
> Java之所以性能慢的一个原因，主要是有java不支持栈上分配对象。所以减少临时对象在堆内分配的数量是最有效的方法。
一般在方法体声明了一个局部变量字后，且未发生逃逸，而按照JVM内存分配机制会在堆内存创建类的对象并且将引用压入栈中。
但如果使用逃逸分析对JVM进行优化。

-  分析兵器找到未逃逸的变量
+  将按照变量类的实例化内存直接在栈分配，无需入堆
+  分配完成后继续调用栈内执行
+  线程结束，回收栈控件，局部变量对象也被回收
+  优化前后的区别在于一个是堆中，一个是在栈中，从而减少了堆中**临时对象**的分配

---
## 3.逃逸优化程序的三个类型
>堆分配对象变成栈分配对象：一个方法当中的对象，对象的引用没有发生逃逸，那么这个方法可能会被分配在栈内存上而非常见的堆内存上。 
消除同步：线程同步的代价是相当高的，同步的后果是降低并发性和性能。逃逸分析可以判断出某个对象是否始终只被一个线程访问，如果只被一个线程访问，那么对该对象的同步操作就可以转化成没有同步保护的操作，这样就能大大提高并发程度和性能。 
矢量替代：逃逸分析方法如果发现对象的内存存储结构不需要连续进行的话，就可以将对象的部分甚至全部都保存在CPU寄存器内，这样能大大提高访问速度。

---
## 4.对象的三种逃逸状态
>GlobalEscape（全局逃逸）： 即一个对象的引用逃出了方法或者线程。例如，一个对象的引用是复制给了一个类变量，或者存储在在一个已经逃逸的对象当中，或者这个对象的引用作为方法的返回值返回给了调用方法。 
ArgEscape（参数级逃逸）：即在方法调用过程当中传递对象的应用给一个方法。这种状态可以通过分析被调方法的二进制代码确定。 
NoEscape（没有逃逸）：一个可以进行标量替换的对象。该对象可以不被分配在传统的堆上。

---
## 5.如何判断是否逃逸的例子
```
class A {  
public static B b;  
    public void globalVariablePointerEscape() { 
        //给全局变量赋值，发生逃逸 
        b = new B();  
    }  
    public B methodPointerEscape() { 
        //方法返回值，发生逃逸
        return new B();  
    }  
    public void instancePassPointerEscape() {  
        methodPointerEscape().printClassName(this); 
        //实例引用传递，发生逃逸
    }  
}  
class B {  
    public void printClassName(A a) {  
        System.out.println(a.class.getName());  
    }  
}
```

